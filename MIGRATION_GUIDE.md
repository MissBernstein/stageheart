# Migration Guide: Updating Code for New Schema

This guide helps you update your application code to work with the new songs schema structure.

## Key Changes Summary

1. **Field Rename**: `title` → `song_title` (canonical field)
2. **New Fields**: `public_id`, `parent_song_id`, `version_label`
3. **Improved Slugs**: Now based on `artist + song_title` 
4. **Case-Insensitive Uniqueness**: Prevents duplicates like "Adele - Hello" vs "adele - hello"

## 1. Update Database Queries

### Before (old queries):
```typescript
// ❌ Old way
const { data } = await supabase
  .from('songs')
  .select('id, slug, title, artist, feeling_cards(*)')
```

### After (new queries):
```typescript
// ✅ New way
const { data } = await supabase
  .from('songs')
  .select(`
    id,
    slug,
    song_title,
    artist,
    public_id,
    parent_song_id,
    version_label,
    feeling_cards(*)
  `)
```

## 2. Update Hooks

### `useAllSongs.ts` Updates:
```typescript
// Replace the query section:
const { data, error } = await supabase
  .from('songs')
  .select(`
    id,
    slug,
    song_title,
    artist,
    public_id,
    created_at,
    feeling_cards (
      summary,
      theme,
      core_feelings,
      access_ideas,
      visual,
      created_at
    )
  `)
  .limit(2000);

// Update the mapping function:
const mapped: Song[] = (data as RowAny[]).map(r => {
  const fcRaw = (r as any).feeling_cards;
  return {
    id: r.id,
    title: r.song_title, // ✅ Use song_title
    artist: r.artist,
    slug: r.slug,
    public_id: r.public_id, // ✅ New field
    summary: fcRaw?.summary || '',
    theme: fcRaw?.theme || '',
    core_feelings: fcRaw?.core_feelings || [],
    access_ideas: fcRaw?.access_ideas || [],
    visual: fcRaw?.visual || '🎵',
    created_at: r.created_at,
  };
});
```

### `useRemoteSongs.ts` Updates:
```typescript
// Update the query:
const { data, error } = await supabase
  .from('feeling_cards')
  .select(`
    song_id,
    summary,
    theme,
    visual,
    core_feelings,
    access_ideas,
    created_at,
    songs (
      id,
      song_title,
      artist,
      slug,
      public_id,
      created_at
    )
  `)
  .limit(500);

// Update the mapping:
const converted: Song[] = data
  .filter(item => item.songs)
  .map(item => ({
    id: item.songs.id,
    title: item.songs.song_title, // ✅ Use song_title
    artist: item.songs.artist,
    slug: item.songs.slug,
    public_id: item.songs.public_id, // ✅ New field
    summary: item.summary,
    theme: item.theme,
    core_feelings: item.core_feelings,
    access_ideas: item.access_ideas,
    visual: item.visual || '🎵',
    created_at: item.created_at,
  }));
```

## 3. Update Form Submissions

### `AddSong.tsx` and Submission Handler:
```typescript
// ✅ New submission format
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  setLoading(true);

  try {
    const response = await fetch('/api/submit-song', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        artist: artist.trim(),
        song_title: title.trim(), // ✅ Use song_title field
        // slug will be auto-generated from artist + song_title
      })
    });
    // ... rest of handler
  } catch (error) {
    // ... error handling
  }
};
```

### Supabase Functions Update:
```typescript
// In process-submissions/index.ts
const { data: newSong, error: songError } = await supabase
  .from('songs')
  .insert({
    song_title: sub.title, // ✅ Use song_title
    artist: sub.artist,
    // slug auto-generated by trigger
    // public_id auto-generated
  })
  .select('id, public_id')
  .single();
```

## 4. Update Search Functionality

### Enhanced Search with Trigram:
```typescript
// ✅ New search using combined artist + song_title index
const searchSongs = async (searchTerm: string) => {
  const { data } = await supabase
    .from('songs')
    .select(`
      id,
      song_title,
      artist,
      slug,
      public_id,
      feeling_cards(summary, theme, core_feelings)
    `)
    .textSearch('fts', searchTerm) // Uses the new trigram index
    .limit(20);
    
  return data?.map(song => ({
    ...song,
    title: song.song_title, // Map for display
  }));
};
```

## 5. Update URL Generation and Routing

### Slug-based URLs (more stable now):
```typescript
// ✅ Slugs are now artist+title based, much more unique
const generateSongUrl = (song: Song) => `/song/${song.slug}`;

// ✅ For stable references (favorites, i18n), use public_id
const generateStableReference = (song: Song) => song.public_id;
```

## 6. Update i18n and Translation Keys

### Transition to Stable Keys:
```typescript
// ✅ Use public_id for stable translation keys
export const songContentKey = (song: Song, field: string) => 
  `songContent.songs.${song.public_id}.${field}`;

// 🔄 Fallback to slug during transition period
export const songContentKeyWithFallback = (song: Song, field: string) => {
  const publicIdKey = `songContent.songs.${song.public_id}.${field}`;
  const slugKey = `songContent.summaries.${song.slug}`;
  
  const translated = t(publicIdKey, '');
  return translated || t(slugKey, '');
};
```

## 7. Update Favorites System

### Use Public ID for Stability:
```typescript
// ✅ Store favorites by public_id instead of slug
const addToFavorites = (song: Song) => {
  const favorites = getFavorites();
  favorites.push(song.public_id); // Not song.slug
  localStorage.setItem('favorites', JSON.stringify(favorites));
};

const isFavorite = (song: Song) => {
  const favorites = getFavorites();
  return favorites.includes(song.public_id);
};
```

## 8. Handle Covers and Versions

### New Cover/Version Support:
```typescript
// ✅ Create a cover version
const createCoverSong = async (originalSong: Song, versionInfo: {
  artist: string;
  version_label: string;
}) => {
  const { data } = await supabase
    .from('songs')
    .insert({
      song_title: originalSong.title, // Same title
      artist: versionInfo.artist, // Different artist
      version_label: versionInfo.version_label, // e.g., "Live 2009"
      parent_song_id: originalSong.id, // ✅ Link to original
      is_cover: true, // Temporary field
    })
    .select('*')
    .single();
    
  return data;
};

// ✅ Find all versions of a song
const findSongVersions = async (songId: string) => {
  const { data } = await supabase
    .from('songs')
    .select('*')
    .or(`id.eq.${songId},parent_song_id.eq.${songId}`);
    
  return data;
};
```

## 9. Migration Steps Checklist

- [ ] **Apply the database migration** (run the .sql file)
- [ ] **Update TypeScript types** (use the new schema types)
- [ ] **Update database queries** (use `song_title` instead of `title`)
- [ ] **Update hooks** (`useAllSongs`, `useRemoteSongs`)
- [ ] **Update form submissions** (send `song_title` field)
- [ ] **Update search functionality** (leverage new indexes)
- [ ] **Update URL generation** (slugs are now more unique)
- [ ] **Migrate favorites system** (use `public_id` for stability)
- [ ] **Test bulk imports** (use new composite uniqueness)
- [ ] **Validate migration** (run the validation script)

## 10. Rollback Plan (if needed)

If you need to rollback, the migration is designed to be non-destructive:

1. The old `title` field is preserved
2. All existing data is backfilled into `song_title`
3. Existing slugs are updated but not removed
4. You can temporarily map `song_title` back to `title` if needed

```sql
-- Emergency rollback (if absolutely necessary)
UPDATE songs SET title = song_title WHERE title IS NULL;
-- Then update your code to use title again temporarily
```

However, it's recommended to move forward with the new schema for the benefits it provides.